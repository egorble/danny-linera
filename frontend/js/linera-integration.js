// Linera Integration –¥–ª—è Danny VS CatGirls
class LineraGameIntegration {
    constructor() {
        this.wallet = null;
        this.client = null;
        this.chainId = null;
        this.isInitialized = false;
        this.gameContract = null;
        this.playerName = null;
        this.isGameConfigured = false;
        
        // Configuration for Danny VS CatGirls contract
        this.appId = null; // Will be set from environment or prompt
        this.leaderboardChainId = null; // Will be set during setup
    }

    async initialize() {
        try {
            this.updateStatus('üîÑ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è Linera SDK...');
            
            // –Ü–º–ø–æ—Ä—Ç—É—î–º–æ Linera –º–æ–¥—É–ª—å
            const linera = await import('@linera/client');
            console.log('Linera module loaded:', linera);
            
            // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebAssembly
            this.updateStatus('üîÑ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebAssembly...');
            await linera.default();
            
            // –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ faucet —ñ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ—à–µ–ª—å–∫–∞
            this.updateStatus('üîÑ –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ—à–µ–ª—å–∫–∞...');
            const faucet = await new linera.Faucet(
                'https://faucet.testnet-babbage.linera.net'
            );
            
            this.wallet = await faucet.createWallet();
            this.client = await new linera.Client(this.wallet);
            
            // –û—Ç—Ä–∏–º—É—î–º–æ –Ω–æ–≤–∏–π –ª–∞–Ω—Ü—é–≥ –∑ —Ç–æ–∫–µ–Ω–∞–º–∏
            this.updateStatus('üîÑ –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–∏—Ö —Ç–æ–∫–µ–Ω—ñ–≤...');
            this.chainId = await faucet.claimChain(this.client);
            
            // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç
            await this.initializeContract();
            
            // –û–Ω–æ–≤–ª—é—î–º–æ UI
            this.updateChainInfo();
            this.updateStatus('‚úÖ –ì–æ—Ç–æ–≤–æ –¥–æ –≥—Ä–∏!');
            
            this.isInitialized = true;
            console.log('Linera initialized successfully:', {
                chainId: this.chainId,
                wallet: this.wallet,
                playerName: this.playerName
            });
            
            // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –ª–∞–Ω—Ü—é–≥ —Ç–∞ –æ–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å –ª—ñ–¥–µ—Ä–±–æ—Ä–¥–∞ —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥–∏
            setTimeout(() => {
                document.getElementById('chainInfo').style.display = 'block';
                this.updateLeaderboardStatus();
            }, 2000);
            
        } catch (error) {
            console.error('Failed to initialize Linera wallet:', error);
            this.updateStatus('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Linera');
            
            // –ü–æ–∫–∞–∑—É—î–º–æ –¥–µ—Ç–∞–ª—å–Ω—É –ø–æ–º–∏–ª–∫—É –≤ –∫–æ–Ω—Å–æ–ª—ñ
            if (error.message) {
                console.error('Error message:', error.message);
            }
        }
    }

    async initializeContract() {
        try {
            // Get player name
            this.playerName = this.promptPlayerName();
            
            // Set app ID (you'll need to replace this with your deployed contract ID)
            this.appId = prompt('–í–≤–µ–¥—ñ—Ç—å ID –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ Danny VS CatGirls (–∞–±–æ –∑–∞–ª–∏—à—Ç–µ –ø–æ—Ä–æ–∂–Ω—ñ–º –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è):') || 'default-app-id';
            
            // Use current chain as leaderboard chain for simplicity
            this.leaderboardChainId = this.chainId;
            
            // Initialize contract frontend
            this.gameContract = await this.client.frontend().application(this.appId);
            
            // Try to get current state
            const stateQuery = `query {
                playerName
                best
                isLeaderboardChain
            }`;
            
            const response = await this.gameContract.query(JSON.stringify({ query: stateQuery }));
            const data = JSON.parse(response).data;
            
            console.log('Current contract state:', data);
            
            // Set up the game if needed
            await this.setupGame();
            
        } catch (error) {
            console.error('Failed to initialize contract:', error);
            // Continue anyway - the contract might not be deployed yet
        }
    }

    async setupGame() {
        try {
            this.updateStatus('üîÑ –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≥—Ä–∏...');
            
            const setupQuery = `mutation {
                setupGame(
                    leaderboardChainId: "${this.leaderboardChainId}",
                    leaderboardName: "${this.playerName}"
                )
            }`;
            
            const queryObject = { query: setupQuery };
            await this.gameContract.query(JSON.stringify(queryObject));
            console.log('Game setup completed with player:', this.playerName);
            this.isGameConfigured = true;
            
        } catch (error) {
            console.log('Game setup skipped:', error.message);
            // Continue anyway - might already be set up
        }
    }

    promptPlayerName() {
        const name = prompt('–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º\'—è (–º–∞–∫—Å. 20 —Å–∏–º–≤–æ–ª—ñ–≤):');
        if (name && name.trim()) {
            return name.trim().substring(0, 20);
        }
        return `–ì—Ä–∞–≤–µ—Ü—å${Math.floor(Math.random() * 1000)}`;
    }

    updateStatus(message) {
        const statusElement = document.getElementById('walletStatus');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }

    updateChainInfo() {
        const chainIdElement = document.getElementById('chainId');
        if (chainIdElement && this.chainId) {
            chainIdElement.textContent = this.chainId.substring(0, 8) + '...';
        }
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –∫–æ—à–µ–ª–µ–∫
    getWalletInfo() {
        if (!this.isInitialized) {
            return null;
        }
        
        return {
            chainId: this.chainId,
            wallet: this.wallet,
            client: this.client
        };
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å—É (–¥–ª—è –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è)
    async getBalance() {
        if (!this.isInitialized || !this.client) {
            throw new Error('Linera not initialized');
        }
        
        try {
            // –¢—É—Ç –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –ª–æ–≥—ñ–∫—É –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É
            // return await this.client.getBalance();
            return 0; // –ø–æ–∫–∏ —â–æ –∑–∞–≥–ª—É—à–∫–∞
        } catch (error) {
            console.error('Failed to get balance:', error);
            throw error;
        }
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –≤–±–∏–≤—Å—Ç–≤ –ø—ñ–¥ —á–∞—Å –≥—Ä–∏
    async updateKills(kills) {
        if (!this.isInitialized || !this.gameContract) {
            console.log('Contract not ready, skipping kills update');
            return false;
        }
        
        try {
            const updateQuery = `mutation {
                increment(value: 1)
            }`;
            
            const queryObject = { query: updateQuery };
            await this.gameContract.query(JSON.stringify(queryObject));
            return true;
        } catch (error) {
            console.error('Failed to update kills:', error);
            return false;
        }
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ñ—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
    async submitFinalScore(kills, survivalTime) {
        if (!this.isInitialized || !this.gameContract) {
            console.log('Contract not ready, cannot submit score');
            return false;
        }
        
        try {
            // Submit the final score
            const submitQuery = `mutation {
                setBestAndSubmit(best: ${kills})
            }`;
            
            const queryObject = { query: submitQuery };
            await this.gameContract.query(JSON.stringify(queryObject));
            
            console.log('Score submitted successfully:', kills);
            
            // Fetch updated leaderboard
            await this.fetchLeaderboard();
            
            return true;
        } catch (error) {
            console.error('Failed to submit final score:', error);
            return false;
        }
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª—ñ–¥–µ—Ä–±–æ—Ä–¥–∞
    async fetchLeaderboard() {
        if (!this.isInitialized || !this.gameContract) {
            console.log('Contract not ready, cannot fetch leaderboard');
            return [];
        }
        
        try {
            // Request leaderboard update if we're configured
            if (this.isGameConfigured) {
                const requestQuery = `mutation {
                    requestLeaderboard
                }`;
                
                const queryObject = { query: requestQuery };
                await this.gameContract.query(JSON.stringify(queryObject));
            }
            
            // Fetch leaderboard data
            const leaderboardQuery = `query {
                leaderboard {
                    playerName
                    score
                    chainId
                    timestamp
                }
                myRank
                playerName
                best
            }`;
            
            const queryObject = { query: leaderboardQuery };
            const response = await this.gameContract.query(JSON.stringify(queryObject));
            const data = JSON.parse(response).data;
            
            console.log('Leaderboard data:', data);
            
            return {
                leaderboard: data.leaderboard || [],
                myRank: data.myRank,
                playerName: data.playerName,
                best: data.best
            };
            
        } catch (error) {
            console.error('Failed to fetch leaderboard:', error);
            return {
                leaderboard: [],
                myRank: null,
                playerName: this.playerName,
                best: 0
            };
        }
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≥—Ä–∞–≤—Ü—è
    async getPlayerStats() {
        if (!this.isInitialized || !this.gameContract) {
            return {
                playerName: this.playerName || 'Unknown',
                best: 0,
                currentValue: 0,
                rank: null
            };
        }
        
        try {
            const statsQuery = `query {
                playerName
                best
                value
                myRank
            }`;
            
            const queryObject = { query: statsQuery };
            const response = await this.gameContract.query(JSON.stringify(queryObject));
            const data = JSON.parse(response).data;
            
            return {
                playerName: data.playerName,
                best: data.best,
                currentValue: data.value,
                rank: data.myRank
            };
            
        } catch (error) {
            console.error('Failed to get player stats:', error);
            return {
                playerName: this.playerName || 'Unknown',
                best: 0,
                currentValue: 0,
                rank: null
            };
        }
    }

    updateLeaderboardStatus() {
        const statusElement = document.getElementById('leaderboardStatusText');
        if (statusElement) {
            if (this.isInitialized && this.gameContract) {
                statusElement.textContent = '–ê–∫—Ç–∏–≤–Ω–∏–π';
                document.getElementById('leaderboardStatus').style.display = 'block';
            } else {
                statusElement.textContent = '–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π';
                document.getElementById('leaderboardStatus').style.display = 'block';
            }
        }
    }
}

// –°—Ç–≤–æ—Ä—é—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω–∏–π –µ–∫–∑–µ–º–ø–ª—è—Ä
window.lineraIntegration = new LineraGameIntegration();

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏
document.addEventListener('DOMContentLoaded', () => {
    window.lineraIntegration.initialize();
});

export default LineraGameIntegration; 